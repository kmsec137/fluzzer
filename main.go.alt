package main


var keywords := []string{"and","import","not","return","option","test","empty","in","or","package"}

type Production_t struct {
	name string
	expression Expression_t
}

type Expression_t struct {
	alternative Alternative_t
	conditional ConditionalExpression_t
}

type ConditionalExpression_t struct {
	logical LogicalExpression_t
	_if Expression_t
	_then Expression_t
	_else Expression_t
}

type LogicalExpression_t struct {
	op UnaryLogicalExpression_t
	expr BinaryLogicalExpression_t
}

type BinaryLogicalExpression_t struct {
	lhs LogicalExpression_t
	op LogicalOperator_t
	rhs UnaryLogicalExpression_t
}

type UnaryLogicalExpression struct {
	op ComparisonExpression_t
	expr UnaryLogicalTruple_t
}

type UnaryLogicalTruple_t struct {
	op UnaryLogicalOperator_t
	expr UnaryLogicalExpression_t
}

type ComparisonExpression_t struct {
	op MultiplicativeExpression_t
	expr ComparisonTruple_t
}

type ComparisonTruple_t struct {
	lhs ComparisonExpression_t
	op ComparisonOperator_t
	rhs AdditiveExpression_t
}

type AdditiveExpression_t struct {
	op MultiplicativeExpression_t
	expr AdditiveTruple_t
}

type AdditiveTruple_t struct {
	lhs AdditiveExpression_t
	op AdditiveOperator_t
	rhs MultiplicativeExpression_t
}

type MultiplicativeExression_t struct {
	op ExponentExpression_t
	expr MultiplicativeTruple_t
}

type MultiplicativeTruple_t struct {
	lhs ExponentExpression_t
	op MultiplicativeOperator_t
	rhs MultiplicativeExpression_t
}

type ExponentExpression_t struct {
	op PipeExpression_t
	expr ExponentTruple_t
}

type PipeExpression_t struct {
	op PostfixExpression_t
	expr PipeTruple_t
}

type PipeTruple_t struct {
	lhs PipeExpression_t
	op PipeOperator_t
	rhs UnaryExpression_t
}

type UnaryExpression_t struct {
	op PostfixExpression_t
	expr UnaryTruple_t
}

type UnaryTruple_t struct {
	op PrefixOperator_t
	expr UnaryExpression_t
}

type PostfixExpression_t struct {
	op PrimaryExpression_t
	expr PostfixTruple_t
}

type PostfixTruple_t struct {
	op PostfixExpression_t
	expr PostfixOperator_t
}
type PostfixOperator_t struct {
	op MemberExpression_t
	expr PostfixOpTruple_t
}
type PostfixOpTruple_t struct {
	op CallExpression_t
	expr IndexExpression_t
}

type MemberExpression_t struct {
	op DotExpression_t
	expr MemberBracketExpression_t
}
type DotExpression_t struct { //prefix with a "."
	op string := "."
	expr Identifier_t
}
type MemberBracketExpression_t struct {
	lhs string := "["
	op string
	rhs string := "]"
	
}

type CallExpression_t struct {
	
}

type IndexExpression_t struct {
	
}


type ComparisonOperator_t := string[]{""}
type PipeOperator_t := string[]{"|>"}
type PrefixOperator_t := string[]{"+","-"}
type LogicalOperator_t := string[]{"and","or"}
type UnaryLogicalOperator_t := string[]{"not","exists"}
type AdditiveOperator_t := string[]{"+","-"}
type MultiplicativeOperator_t := string {"*","/","%"}
type ExponentOperator_t := string {"^"}

type Alternative_t struct {
	term Term_t
}
type Term_t struct {
	name string
	token Token_t
	group Group_t
	option Option_t
	Rep Repitition_t

}
type Token_t struct {
	identifier Identifier_t
	keyword Keyword_t
	operator Operator_t
	literal Literal_t

}

type Identifier_t struct {

}
type Keyword_t struct {
	
}
type Operator_t struct {
	
}
type Literal_t struct {
	
}

type iProduction interface {
	generate() string
	next() Expression_t
}

type iExpression interface {
	generate() string
	next() ConditionalExpression_t
}
type iConditional interface {
	generate() string	
	next() LogicalExpression_t
	_if() Expression_t
	_then() Expression_t
	_else() Expression_t
}

type iLogicalExpression interface {
	generate() string
	
}
type iUnaryLogicalExpression interface {
	generate() string	
}
type iComparisionExpression interface {
	generate() string
}
type iUnaryLogicalOperator interface {
	generate() string
}
type AdditiveExpression interface {
	generate() string
}
type iAlternative interface {
	generate() string
}

type iTerm interface {
	name() string
	token() string
	group() string
	option() string
	rep() string

}
type iToken interface {
	identifier() string
	keyword() string
	operator() string
	literal() string

}
type iIdentifier interface {
	generate() string
	chain() string

}

type iKeyword interface {
	
}
type iOperator interface {
	
}
type iLiteral interface {
	
}
//generate a full flux statement from nothing using random weightings for AST choices
func (prod Production_t) generate(){ //this should call exrepssion .generate
	return iExpression.generate()
}
func (expr Expression_t) generate(){
	//we have an option now of generating a chain of alternatives concatenated with a "|" according to the spec
	return
}
func main(){
	return 0
}

