package main

import (
	"math/rand"
	"time"
)
/**
	* literals are not enunciated here we will fuzz them in an unstructed way

	* psuedo code:
		input: binary string of digits
		output: random flux program
			process:
				- if a binary number is 1/0 choose either branch (production rule) in the grammar, recurse.
				- if the seed is fully consumed choose the closest terminator
	* we consume a binary number for each element in the grammar, should we run out of numbers
		we then choose the closes terminator or string literal (might need some work discovering this)
	* should there be an automated way to convert a grammar into a normal form that allows for binary disovery?
	
**/

//var keywords := []string{"and","import","not","return","option","test","empty","in","or","package"}

type Production_t struct {
	op string
	expr Expression_t
}

type Expression_t struct {
	op *Alternative_t
	expr *ConditionalExpression_t
}

type ConditionalExpression_t struct {
	op LogicalExpression_t
	expr ConditionalExpressionTruple_t
}

type ConditionalExpressionTruple_t struct {

	op Expression_t //if 
	expr SubConditionalExpressionTruple_t //then
}

type SubConditionalExpressionTruple_t struct {
	op Expression_t //then
	expr Expression_t //else
}

type LogicalExpression_t struct {
	op UnaryLogicalExpression_t
	expr BinaryLogicalExpression_t
}

type BinaryLogicalExpression_t struct {
	lhs *LogicalExpression_t
	op LogicalOperator_t
	rhs *UnaryLogicalExpression_t
}

type UnaryLogicalExpression_t struct {
	op ComparisonExpression_t
	expr *UnaryLogicalTruple_t
}

type UnaryLogicalTruple_t struct {
	op UnaryLogicalOperator_t
	expr *UnaryLogicalExpression_t
}

type ComparisonExpression_t struct {
	op *MultiplicativeExpression_t
	expr ComparisonTruple_t
}

type ComparisonTruple_t struct {
	lhs *ComparisonExpression_t
	op ComparisonOperator_t
	rhs *AdditiveExpression_t
}

type AdditiveExpression_t struct {
	op *MultiplicativeExpression_t
	expr AdditiveExpressionTruple_t
}

type AdditiveExpressionTruple_t struct {
	lhs *AdditiveExpression_t
	op AdditiveOperator_t
	rhs *MultiplicativeExpression_t
}

type MultiplicativeExression_t struct {
	op *ExponentExpression_t
	expr *MultiplicativeExpressionTruple_t
}

type MultiplicativeExpressionTruple_t struct {
	lhs *ExponentExpression_t
	op *MultiplicativeOperator_t
	rhs *MultiplicativeExpression_t
}

type MultiplicativeExpression_t struct {
	op ExponentExpression_t
	expr MultiplicativeExpressionTruple_t
}

type ExponentExpression_t struct {
	op PipeExpression_t
	expr ExponentExpressionTruple_t
}
type ExponentExpressionTruple_t struct {
	lhs *ExponentExpression_t
	op ExponentOperator_t
	rhs *PipeExpression_t
}

type PipeExpression_t struct {
	op PostfixExpression_t
	expr *PipeExpressionTruple_t
}

type PipeExpressionTruple_t struct {
	lhs *PipeExpression_t
	op PipeOperator_t
	rhs *UnaryExpression_t
}

type UnaryExpression_t struct {
	op PostfixExpression_t
	expr UnaryTruple_t
}

type UnaryTruple_t struct {
	op PrefixOperator_t
	expr *UnaryExpression_t
}

type PostfixExpression_t struct {
	op PrimaryExpression_t
	expr PostfixExpressionTruple_t
}

type PrimaryExpression_t struct {
	op Identifier_t //should terminate in a literal soon
	expr PrimaryExpressionTruple_t
}

type PrimaryExpressionTruple_t struct {
	op Identifier_t
	expr Expression_t
}

type PostfixExpressionTruple_t struct {
	op *PostfixExpression_t
	expr PostfixOperator_t
}

type PostfixOperator_t struct {
	op MemberExpression_t
	expr PostfixOperatorTruple_t
}

type PostfixOperatorTruple_t struct {
	op CallExpression_t
	expr IndexExpression_t
}

type MemberExpression_t struct {
	op DotExpression_t
	expr MemberBracketExpression_t
}
type DotExpression_t struct { //prefix with a "."
	expr Identifier_t
}
type MemberBracketExpression_t struct {
	op string
}

type CallExpression_t struct {
	op PropertyList_t
}

type PropertyList_t struct {
	op []Property_t //needs to be an array of properties
}

type Property_t struct {
	op LHSProperty_t
	expr RHSProperty_t
}

type LHSProperty_t struct {
	op Identifier_t
	expr Expression_t
}

type RHSProperty_t struct {
	op string
	expr Expression_t
}

type IndexExpression_t struct {
	op Expression_t //remember brackets
}

//type ComparisonOperator_t []string
type ComparisonOperator_t struct {
	op string
}

//type PipeOperator_t []string //{"|>"}
type PipeOperator_t struct {
	op string
}

//type PrefixOperator_t []string //{"+","-"}
type PrefixOperator_t struct {
	op string
}

//type LogicalOperator_t []string //{"and","or"}
type LogicalOperator_t struct {
	op string
}

type UnaryLogicalOperator_t struct {
	op string
}

type AdditiveOperator_t struct {
	op string
}

type MultiplicativeOperator_t struct {
	op string
}

type ExponentOperator_t struct {
	op string
}

type Alternative_t struct {
	term Term_t
}

type Term_t struct {
	op string
	expr TermTruple_t
}

type TermTruple_t struct {
	op Token_t
	expr SubTermTruple_t
}

type SubTermTruple_t struct {
	op Group_t
	expr SubSubTermTruple_t
}
type Group_t struct {
	op Expression_t
}

type SubSubTermTruple_t struct {
	op Option_t
	expr Repetition_t
}
type Option_t struct {
	op Expression_t
}

type Repetition_t struct {
	op Expression_t
}

type Token_t struct {
	op Identifier_t
	expr SubTokenTruple_t
}

type SubTokenTruple_t struct {
	op Keyword_t
	expr SubSubTokenTruple_t
}

type SubSubTokenTruple_t struct {
	op Operator_t
	expr Literal_t
}

type Identifier_t struct {
	op string //letter
	expr string
}

type Keyword_t struct {
 	op string	
}
type Operator_t struct {
	op string	
}
type Literal_t struct {
	op string
}
func init_random() {
	rand.Seed(time.Now().UnixNano())
}
func generate_string() string {
	return "string" //TODO: need to replace this with a string generator
}

func (lit Literal_t) generate(seed string, index int) string {
	return "literal" //TODO: fix once we get everything working
}

func (memb MemberBracketExpression_t) generate(seed string, index int) string{
	return "[" + generate_string() + "]"
}

func (i Identifier_t) generate(seed string, index int) string{
	return "identifier" //replace with random string when this works
}

func (dot DotExpression_t) generate(seed string, index int) string{
	return "." + Identifier_t.generate(seed,index)
}

func (mem MemberExpression_t) generate(seed string, index int) string {
	if index < len(seed){
		switch {
			case '0' == seed[index]:
				return DotExpression_t.generate(seed,index+1)
			case '1' == seed[index]:
				return MemberBracketExpression_t.generate(seed,index+1)
		}
	}
}
func (post PostfixOperatorTruple_t) generate(seed string, index int) string{
	if index < len(seed){
		switch {
			case '0' == seed[index]:
				return CallExpression_t.generate(seed,index+1)
			case '1' == seed[index]:
				return IndexExpression_t.generate(seed,index+1)
		}
	}
}
func (call CallExpression_t) generate(seed string, index int) string {
	return "(" + PropertyListExpression_t.generate(seed,index) + ")"
}

func (prop PropertyListExpression_t) generate(seed string, index int) string {
	var out string = "";
	for i := 0; i < len(10); i++ { //need to randomize the propertylist
		out += Property_t.generate(seed,index) + ","
	}
	return out
}
func (prop Property_t) generate(seed string, index int) string {
	if index < len(seed) {
		switch {
			case '0' == seed[index]:
				return LHSProperty_t.generate(seed,index+1)
			case '1' == seed[index]:
				return RHSProperty_t.generate(seed,index+1)
		}
	}
}
func (rhs RHSProperty_t) generate(seed string, index int) string{
	return Identifier_t.generate(seed,index) + ":" + Expression_t.generate(seed,index)
}

func (lhs LHSProperty_t) generate(seed string, index int) string {
	return "prop" + generate_string() + ":" + Expression_t.generate(seed,index)
}

func (index IndexExpression_t) generate(seed string, index int){
	return "[" + Expression_t.generate(seed,index) + "]"
}



func (comp ComparisonTruple_t) generate(seed string, index int) string {
	return ComparisonExpression_t.generate() + ComparisonOperator_t.generate() + AdditiveExpression_t.generate()
}

func (add AdditiveExpression_t) generate(seed string, index int) string {
	if index < len(seed) {
		switch {
			case '0' == seed[index]:
				return MultiplicativeExpression_t.generate(seed,index+1)
			case '1' == seed[index]:
				return AdditiveExpressionTruple_t.generate(seed,index+1)
		}
	}
}

func (add_tup AdditiveExpressionTruple_t) generate(seed string, index int){
	return AdditiveExpression_t.generate(seed,index) + AdditiveOperator_t.generate(seed,index) + MultiplicativeExpression_t.generate(seed,index)
}

func (unary UnaryLogicalTruple_t) generate(seed string, index int) string {
	return UnaryLogicalOperator_t.generate(seed,index) + UnaryLogicalExpression_t.generate(seed,index)
}
func (unary UnaryLogicalOperator_t) generate() string {
	if index < len(seed){
			switch {
				case '0' == seed[index]:
					return "not"
				case '1' == seed[index]:
					return "exists"
			}
	}
}

func (pipe_op PipeOperator_t) generate(seed string, index int) string {
	return "|>"
}

func (pre PrefixOperator_t) generate(seed string, index int) string {
	if index < len(seed) {
		switch {
			case '0' == seed[index]:
				return "+"
			case '1' == seed[index]:
				return "-"
		}
	}
}
func (post_op PostfixOperator_t) generate(seed string, index int) string {
	if index < len(seed){
		switch {
			case '0' == seed[index]:
				return MemberExpression_t.generate(seed,index+1)
			case '1' == seed[index]:
				return PostfixOperatorTruple_t.generate(seed,index+1)
		}
	}
}
func (log LogicalOperator_t) generate(seed string, index int) string {
	if index < len(seed) {
		switch {
			case '0' == seed[index]:
				return "and"
			case '1' == seed[index]:
				return "or"
		}
	}
}
func (unary AdditiveOperator_t) generate(seed string, index int) string {
	if index < len(seed) {
		switch {
			case '0' == seed[index]:
				return "+"
			case '1' == seed[index]:
				return "-"
		}
	}
}

func (mul MultiplicativeOperator_t) generate(seed string, index int) string {
	if index < len(seed) {
		switch {
			case '0' == seed[index]:
				return "*"
			case '1' == seed[index]:
				return "/"
		} //we don't have a '%' operator
	}
}

func (ex ExponentOperator_t) generate(seed string, index int) string {
	return "^"
}

func (sub SubConditionalExpressionTruple_t) generate(seed string, index int) string {
		return "if " + Expression_t.generate(seed,index) + "then " + Expression_t.generate(seed,index)
					+ "else " + Expression_t.generate(seed,index)
}

func (term Term_t) generate(seed string, index int) string {
	if index < len(seed) {
		switch {
			case '0' == seed[index]:
				return generate_string()
			case '1' == seed[index]:
				return SubTermTruple_t.generate(seed,index)
		}
	}
}
func (alt Alternative_t) generate(seed string, index int) string {
	return Term_t.generate(seed,index)
}



func (sub SubTermTruple_t) generate(seed string,index int) string{
	if index < len(seed) {
		switch {
			case '0' == seed[index]:
				return Group_t.generate(seed,index+1)
			case '1' == seed[index]:
				return SubSubTermTruple_t.generate(seed,index+1)
		}
	}
}
func (subsub SubSubTermTruple_t) generate(seed string, index int) string{
	if index < len(seed) {
		switch {
				case '0' == seed[index]:
					return Option_t.generate(seed,index+1)
				case '1' == seed[index]:
					return Repitition_t.generate(seed,index+1)
		}
	}
}

func (opt Option_t) generate(seed string, index int) string{
	return  "[" + Expression_t.generate(seed, index) + "]"
}

func (rep Repetition_t) generate(seed string, index int) string{
	return "{" + Expression_t.generate(seed,index) + "}"
}

func (grp Group_t) generate(seed string, index int) string{
	if index < len(seed){
		return "(" + Expression_t.generate(seed,index) + ")"
	}
	return "()"
}



func (cond ConditionExpression_t) generate(seed string, index int) string{
	if index < len(seed){
		switch {
			case '0' == seed[index]:
				return LogicalExpression_t.generate(seed,index+1)
			case '1' == seed[index]:
				return SubConditionalExpressionTruple_t.generate(seed,index+1)
		}
	}
}
func (expr Expression_t) generate(seed string, index int) string{
	if index < len(seed){
		switch {
			case '0' == seed[index]:
				return Alternative_t.generate(seed,index+1)
			case '1' == seed[index]:
				return ConditionalExpression_t.generate(seed,index+1)
		}
	}
	return "" //we've consumed the entire bit string
}
func (prod Production_t) generate(seed string,index int) string{
	return Expression_t.generate(seed, index)
}
func (primary PrimaryExpressionTruple_t) generate(seed string, index int) string {
	switch {
		case '0' == seed[index]:
			return "litral" //Literal_t.generate(seed,index)
		case '1' == seed[index]:
			return "(" + Expression_t.generate(seed,index) + ")"
	}
}
func (primary PrimaryExpression_t) generate(seed string, index int) string {
	if index < len(seed) {
		switch {
			case '0' == seed[index]:
				return Identifier_t.generate(seed,index+1)
			case '1' == seed[index]:
				return PrimaryExpressionTruple_t.generate(seed,index+1)
		}
	}
}
func (post PostfixExpression_t) generate(seed string, index int) string {
	if index < len(seed){
		switch {
			case '0' == seed[index]:
					return PrimaryExpression_t.generate(seed,index+1)
			case '1' == seed[index]:
					return PostfixExpressionTruple_t.generate(seed,index+1)
		}
	}
}
func (post_tup PostfixExpressionTruple_t) generate(seed string, index int) string {
	return PostfixExpression_t.generate(seed,index) + PostfixOperator_t.generate()
}
func (pipe PipeExpression_t) generate(seed string, index int) string {
	if index < len(seed){
		switch {
			case '0' == seed[index]:
				return PostfixExpression_t.generate(seed,index+1)
			case '1' == seed[index]:
				return PipeExpressionTruple_t.generate(seed,index+1)
		}

	}
}

func (pipe_tup PipeExpressionTruple_t) generate(seed string, index int) string {
	return PipeExpression_t.generate(seed,index) + "|>" + UnaryExpression_t.generate(seed,index)
}
func (exp ExponentExpression_t) generate(seed string, index int) string {
	if index < len(seed){
		switch {
			case '0' == seed[index]:
				return PipeExpression_t.generate(seed,index+1)
			case '1' == seed[index]:
				return ExponentExpressionTruple_t.generate(seed,index+1)
		}
	}
}

func (exp_tup ExponentExpressionTruple_t) generate(seed string, index int) string {
	return ExponentExpression_t.generate(seed,index) + ExponentOperator_t.generate() + PipeExpression_t.generate()
}


func (mul MultiplicativeExpression_t) generate(seed string, index int) string {
	if index < len(seed) {
		switch {
			case '0' == seed[index]:
				return ExponentExpression_t.generate(seed,index+1)
			case '1' == seed[index]:
				return MultiplicativeExpressionTruple_t.generate(seed,index+1)
		}
	}
}

func (mul MultiplicativeExpressionTruple_t) generate(seed string, index int) string {
	return ExponentExpression_t.generate() + 
				 MultiplicativeOperator_t.generate() + 
						MultiplicativeExpression_t.generate()
}

func (comp ComparisonExpression_t) generate(seed string, index int) string {
	if index < len(seed) {
		switch {
			case '0' == seed[index]:
				return MultiplicativeExpression_t.generate(seed,index+1)
			case '1' == seed[index]:
				return ComparisonTruple_t.generate(seed,index+1)
		}
	}
}
func (unar UnaryLogicalExpression_t) generate(seed string, index int) string {
	if index < len(seed){
		switch {
			case '0' == seed[index]:
				return ComparisonExpression_t.generate(seed,index+1)
			case '1' == seed[index]:
				return UnaryLogicalTruple_t.generate(seed,index+1)
		}
	}
}
func (log LogicalExpression_t) generate(seed string, index int) string {
	if index < len(seed){
		switch {
			case '0' == seed[index]:
				return UnaryLogicalExpression_t.generate(seed,index+1)
			case '1' == seed[index]:
				return BinaryLogicalExpression_t.generate(seed,index+1)
		}
	}
}


func main(){
	fmt.Println(Production_t.generate("1111111111111111111",0))
	return 0
}

